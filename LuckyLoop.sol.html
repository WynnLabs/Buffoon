// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract LuckyLoop is ReentrancyGuard, Ownable {
    // ===== IMMUTABLE CONFIG ===== //
    address public immutable prizePoolWallet = 0x3F449799411d3a2Bc8E232d48282422B4344fe6D;
    address public immutable profitWallet = 0x31Bd345293BB862A913935551ce0a0101efE5194;
    
    // ===== TIER PARAMETERS ===== //
    uint256 public constant TIER1_ENTRY_FEE = 0.00125 ether;
    uint256 public constant TIER1_PRIZE_AMOUNT = 0.025 ether;
    uint256 public constant TIER1_PROFIT_AMOUNT = 0.0125 ether;
    uint256 public constant TIER1_MAX_PARTICIPANTS = 100;

    uint256 public constant TIER2_ENTRY_FEE = 0.0125 ether;
    uint256 public constant TIER2_PRIZE_AMOUNT = 0.25 ether;
    uint256 public constant TIER2_PROFIT_AMOUNT = 0.125 ether;
    uint256 public constant TIER2_MAX_PARTICIPANTS = 100;

    // ===== STATE ===== //
    mapping(uint256 => address[]) public tierParticipants;
    mapping(uint256 => mapping(address => bool)) public hasEntered;
    mapping(uint256 => bool) public isTierActive;

    // ===== EVENTS ===== //
    event Entered(uint256 indexed tier, address participant);
    event WinnerSelected(uint256 indexed tier, address winner);
    event FundsDistributed(uint256 prizeAmount, uint256 profitAmount);

    constructor() Ownable(0x31Bd345293BB862A913935551ce0a0101efE5194) {
        isTierActive[1] = true;
        isTierActive[2] = true;
    }

    // ===== CORE FUNCTIONS ===== //
    function enterLottery(uint256 tier) external payable nonReentrant {
        require(tier == 1 || tier == 2, "Invalid tier");
        require(isTierActive[tier], "Tier inactive");
        require(!hasEntered[tier][msg.sender], "Already entered");

        if (tier == 1) {
            require(msg.value >= TIER1_ENTRY_FEE, "Insufficient Tier 1 fee");
            require(tierParticipants[1].length < TIER1_MAX_PARTICIPANTS, "Tier 1 full");
        } else {
            require(msg.value >= TIER2_ENTRY_FEE, "Insufficient Tier 2 fee");
            require(tierParticipants[2].length < TIER2_MAX_PARTICIPANTS, "Tier 2 full");
        }

        tierParticipants[tier].push(msg.sender);
        hasEntered[tier][msg.sender] = true;

        emit Entered(tier, msg.sender);

        if (tierParticipants[tier].length == (tier == 1 ? TIER1_MAX_PARTICIPANTS : TIER2_MAX_PARTICIPANTS)) {
            _drawWinner(tier);
        }
    }

    // ===== INTERNAL ===== //
    function _drawWinner(uint256 tier) internal {
        uint256 prizeAmount = tier == 1 ? TIER1_PRIZE_AMOUNT : TIER2_PRIZE_AMOUNT;
        uint256 profitAmount = tier == 1 ? TIER1_PROFIT_AMOUNT : TIER2_PROFIT_AMOUNT;
        
        address winner = tierParticipants[tier][_randomIndex(tier)];
        
        (bool sentPrize, ) = winner.call{value: prizeAmount}("");
        (bool sentProfit, ) = profitWallet.call{value: profitAmount}("");
        require(sentPrize && sentProfit, "Transfer failed");

        emit WinnerSelected(tier, winner);
        emit FundsDistributed(prizeAmount, profitAmount);

        // Reset tier
        delete tierParticipants[tier];
    }

    function _randomIndex(uint256 tier) internal view returns (uint256) {
        return uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1),
                    block.timestamp,
                    block.difficulty,
                    tierParticipants[tier]
                )
            )
        ) % (tier == 1 ? TIER1_MAX_PARTICIPANTS : TIER2_MAX_PARTICIPANTS);
    }

    // ===== VIEW FUNCTIONS ===== //
    function getParticipantCount(uint256 tier) external view returns (uint256) {
        require(tier == 1 || tier == 2, "Invalid tier");
        return tierParticipants[tier].length;
    }

    function checkEntry(uint256 tier, address participant) external view returns (bool) {
        require(tier == 1 || tier == 2, "Invalid tier");
        return hasEntered[tier][participant];
    }

    // ===== ADMIN ===== //
    function emergencyWithdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    receive() external payable {}
}